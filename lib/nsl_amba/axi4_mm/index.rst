AXI4-MM
=======

All AXI4-MM related declarations are scoped in the
:vhdl:package:`nsl_amba.axi4_mm` package.

Configuration
-------------

Configuration for AXI4-MM is held in
:vhdl:type:`config_t <nsl_amba.axi4_mm.config_t>` record type. It holds the
follwing settings:

* Address, data, user, ID width,
* Burst signal support and LEN field width,
* Size field support,
* Region, QoS, Cache, Lock fields availability.

:vhdl:func:`config <nsl_amba.axi4_mm.config>` function can generate such a
configuration yet ensuring it makes sense.

AXI4-MM Lite is the subset where data is either 32 or 64-bit, burst is
unsupported and id cache, region, lock and size signals are excluded.
:vhdl:func:`is_lite <nsl_amba.axi4_mm.is_lite>` can tell whether the
configuration matches these constraints.

Signals
-------

Signals are split in the following records:

* Address (:vhdl:type:`address_t <nsl_amba.axi4_mm.address_t>`), both suitable for
  master AW and AR channels.
* Write data (:vhdl:type:`write_data_t <nsl_amba.axi4_mm.write_data_t>`), suitable
  for master W channel.
* Write response (:vhdl:type:`write_response_t <nsl_amba.axi4_mm.write_response_t>`),
  suitable for slave B channel.
* Read data (:vhdl:type:`read_data_t <nsl_amba.axi4_mm.read_data_t>`), suitable for
  slave R channel.
* Handshake (:vhdl:type:`handshake_t <nsl_amba.axi4_mm.handshake_t>`), suitable for
  slave AW, AR and W channels, and slave B and R channels.

Master output port (:vhdl:type:`master_t <nsl_amba.axi4_mm.master_t>`) and slave
output port (:vhdl:type:`slave_t <nsl_amba.axi4_mm.slave_t>`) select relevant
records above for each of their five channels.

An address channel is written to calling
:vhdl:function:`address <nsl_amba.axi4_mm.address--cca580cd>`, all fields are dereferenced
by calling :vhdl:func:`is_valid <nsl_amba.axi4_mm.is_valid--cb9ef90d>`,
:vhdl:func:`id <nsl_amba.axi4_mm.id--6422efec>`,
:vhdl:func:`address <nsl_amba.axi4_mm.address--229e8b89>`,
:vhdl:func:`length_m1 <nsl_amba.axi4_mm.length_m1--229e8b89>`,
:vhdl:func:`burst <nsl_amba.axi4_mm.burst>`,
:vhdl:func:`lock <nsl_amba.axi4_mm.lock--24d05ec6>`,
:vhdl:func:`cache <nsl_amba.axi4_mm.cache--f9ca0ffc>`,
:vhdl:func:`prot <nsl_amba.axi4_mm.prot--9f8b5edc>`,
:vhdl:func:`qos <nsl_amba.axi4_mm.qos--71c0cd71>`,
:vhdl:func:`region <nsl_amba.axi4_mm.region--dc4e0837>`,
:vhdl:func:`user <nsl_amba.axi4_mm.user--6422efec>`.

Write data channel is written to calling
:vhdl:func:`write_data <nsl_amba.axi4_mm.write_data>`, all fields are
dereferenced by calling :vhdl:func:`is_valid <nsl_amba.axi4_mm.is_valid--2beadb49>`,
:vhdl:func:`is_last <nsl_amba.axi4_mm.is_last--2beadb49>`,
:vhdl:func:`bytes <nsl_amba.axi4_mm.bytes--7c5bfbd6>`,
:vhdl:func:`strb <nsl_amba.axi4_mm.strb>`,
:vhdl:func:`value <nsl_amba.axi4_mm.value--8f91746b>`,
:vhdl:func:`mask <nsl_amba.axi4_mm.mask>`,
:vhdl:func:`user <nsl_amba.axi4_mm.user--16e95e3c>`.

Write response channel is written to calling
:vhdl:func:`write_response
<nsl_amba.axi4_mm.write_response--5ad97a97>` (:vhdl:func:`[2]
<nsl_amba.axi4_mm.write_response--7aee4cdf>`) , all fields are
dereferenced by calling :vhdl:func:`is_valid
<nsl_amba.axi4_mm.is_valid--a8f2b8cc>`, :vhdl:func:`id <nsl_amba.axi4_mm.id--d38e752e>`,
:vhdl:func:`resp <nsl_amba.axi4_mm.resp--b856e5e2>`, :vhdl:func:`user
<nsl_amba.axi4_mm.user--d38e752e>`.

Read data channel is written to calling
:vhdl:func:`read_data <nsl_amba.axi4_mm.read_data--f7aec735>`
(:vhdl:func:`[2] <nsl_amba.axi4_mm.read_data--1b1126b2>`), all fields are dereferenced
by calling :vhdl:func:`is_valid <nsl_amba.axi4_mm.is_valid--66380cbc>`,
:vhdl:func:`is_last <nsl_amba.axi4_mm.is_last--66380cbc>`,
:vhdl:func:`bytes <nsl_amba.axi4_mm.bytes--f71d5a65>`,
:vhdl:func:`value <nsl_amba.axi4_mm.value--7a0794f5>`,
:vhdl:func:`id <nsl_amba.axi4_mm.id--be7771e4>`,
:vhdl:func:`resp <nsl_amba.axi4_mm.resp--2339d24e>`,
:vhdl:func:`user <nsl_amba.axi4_mm.user--be7771e4>`.

Handshake channel is writted to calling
:vhdl:func:`accept <nsl_amba.axi4_mm.accept>`, field is dereferenced by
calling :vhdl:func:`is_ready <nsl_amba.axi4_mm.is_ready>`.

Idle constants for all channels are generated by
:vhdl:func:`address_defaults <nsl_amba.axi4_mm.address_defaults>`,
:vhdl:func:`write_data_defaults <nsl_amba.axi4_mm.write_data_defaults>`,
:vhdl:func:`write_response_defaults <nsl_amba.axi4_mm.write_response_defaults>`,
:vhdl:func:`read_data_defaults <nsl_amba.axi4_mm.read_data_defaults>` and
:vhdl:func:`handshake_defaults <nsl_amba.axi4_mm.handshake_defaults>`.

Serializing / getting data
--------------------------

Data vectors are using :vhdl:package:`nsl_data.bytestream`\'s
:vhdl:type:`nsl_data.bytestream.byte_string` type.  Internally, they
are stored in records in ascending address order.  As user often needs
to use byte vectors in descending order or use data on bus as an
unsigned value, accessors for data channels allow to serialize /
deserialize byte vectors in either direction and can spill / extract
unsigned data using either endianness.

For instance, write data serialization function exists in two forms:

.. code-block:: vhdl

   function write_data(cfg: config_t;
                       bytes: byte_string;
                       strb: std_ulogic_vector := na_suv;
                       order: byte_order_t := BYTE_ORDER_INCREASING;
                       user: std_ulogic_vector := na_suv;
                       last: boolean := false;
                       valid: boolean := true)
      return write_data_t;

This version accepts a ``bytes`` byte_string as data field and a ``strb``
vector.  If ``strb`` is left empty, it defaults to all set.  Both can be
in increasing address order or in decreasing address order depending
on the ``order`` argument.

.. code-block:: vhdl

   function write_data(cfg: config_t;
                       value: unsigned := na_u;
                       strb: std_ulogic_vector := na_suv;
                       endian: endian_t := ENDIAN_LITTLE;
                       user: std_ulogic_vector := na_suv;
                       last: boolean := false;
                       valid: boolean := true)
      return write_data_t;

This version accepts a ``value`` unsigned value as data field and a
``strb`` vector.  If ``strb`` is left empty, it defaults to all set.
``value`` has MSB on the left of the vector, ``strb`` has the bit matching
MSB of value on the left.  ``endian`` argument tells how to serialize
this value as a byte string in the data vector. ``strb`` will implicitly
be bitswapped accordingly to match data order.

When extracting data from the same
:vhdl:type:`nsl_amba.axi4_mm.write_data_t`, the following four
functions exit:

.. code-block:: vhdl

  function bytes(cfg: config_t;
                 write_data: write_data_t;
                 order: byte_order_t := BYTE_ORDER_INCREASING)
     return byte_string;

This retrieves the data vector in either byte order.

.. code-block:: vhdl

  function strb(cfg: config_t;
                write_data: write_data_t;
                order: byte_order_t := BYTE_ORDER_INCREASING)
     return std_ulogic_vector;

This retrieves the strobe vector in either byte order, matching data
vector.

.. code-block:: vhdl

  function value(cfg: config_t;
                 write_data: write_data_t;
                 endian: endian_t := ENDIAN_LITTLE)
     return unsigned;

This retrieves the data vector as an unsigned value, as either endianness.

.. code-block:: vhdl

  function mask(cfg: config_t;
                write_data: write_data_t;
                endian: endian_t := ENDIAN_LITTLE)
     return unsigned;

This retrieves the value mask as an unsigned value, as either
endianness (strobe bits are duplicated 8 times to make a mask word).
Of course, in case strobe is not enabled in the configuration, this
returns the relevant default value, which is all set.

Simulation tools
----------------

For simulation purposes, on an AXI4-Lite, there are
:vhdl:func:`lite_write <nsl_amba.axi4_mm.lite_write>`,
:vhdl:func:`lite_read <nsl_amba.axi4_mm.lite_read>` and
:vhdl:func:`lite_check <nsl_amba.axi4_mm.lite_check>` helpers.  They perform
exactly one beat of transfer on a bus.  They can also be used on
full-featured buses.

For bursts on a full-featured bus, there are
:vhdl:func:`burst_write <nsl_amba.axi4_mm.burst_write>`,
:vhdl:func:`burst_read <nsl_amba.axi4_mm.burst_read>` and
:vhdl:func:`burst_check <nsl_amba.axi4_mm.burst_check>`.

For usage examples, see ``test/amba/axi4_mm_*`` test benches
implementation.

Master transactor
-----------------

For bus master needing to read/write constant-sized payloads in
memory, like a DMA scheduler, there exists a
:vhdl:type:`nsl_amba.axi4_mm.transactor_t`.  It may be configured once
through a :vhdl:type:`nsl_amba.axi4_mm.transactor_config_t`.
Transactor context can be used for either reading or writing.  It will
cut read or write in bursts of relevant lengths.  For an usage
example, see ``test/amba/axi_transactor`` test bench implementation.

Slave transaction context
-------------------------

For implementing slaves easilly,
:vhdl:type:`nsl_amba.axi4_mm.transaction_t` helper can handle all
tedious address calculations if needed by configuration (INCR and WRAP
burst modes for instance).
:vhdl:func:`transaction <nsl_amba.axi4_mm.transaction>` must be given an address
channel beat, and then will iterate over all needed
:vhdl:func:`step <nsl_amba.axi4_mm.step>`\s until it reaches the last beat
of transaction.  For an usage example, see
:vhdl:component:`nsl_amba.ram.axi4_mm_ram_full` implementation.

Serialization tools
-------------------

For easier implementation of fifos and other custom modules, there are
generic helpers to encode/decode all the four channels to
``std_ulogic_vector``\s.  They yield the minimal count of bits to encode
beat, depending on the configuration.

Function isolation
------------------

There are two entities available for abstracting basic bus
interfaces.

* :vhdl:component:`nsl_amba.axi4_mm.axi4_mm_lite_slave` is an entity
  taking care of the AXI protocol details and gives an uniform
  synchronous interface to backend access in terms of read and write
  channel, non concurrent.

  .. vhdl:symbol:: nsl_amba.axi4_mm.axi4_mm_lite_slave

* :vhdl:component:`nsl_amba.axi4_mm.axi4_mm_lite_regmap` is
  abstracting even more as it:

  * Allows for a limited address space,
  * Limits to a set of full data width registers,
  * Only uses combinatorial reads.

  This is mostly useful for small register maps.
